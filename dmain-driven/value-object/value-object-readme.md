# 値オブジェクトパターン (Value Object Pattern)

## 概要

値オブジェクトは、ドメイン駆動設計（DDD）の重要な構成要素で、エンティティとは異なり、IDではなく属性によって定義される概念を表現します。値オブジェクトは不変であり、同じ属性を持つ二つの値オブジェクトは同一と見なされます。

## 目的

- 概念的に一つの値として扱える属性のグループをカプセル化する
- 同一性を属性値に基づいて判断する（IDに基づかない）
- ドメイン内の値の概念を明示的に表現する
- 不変性を保証し、予測可能な振る舞いを提供する

## 特性

1. **不変性 (Immutability)**: 作成後に状態を変更できない
2. **値に基づく等価性**: 同じ属性値を持つ二つの値オブジェクトは等価である
3. **自己完結性**: 他のオブジェクトへの参照を持たない（または、持つ場合はそれも値オブジェクト）
4. **交換可能性**: 古い値オブジェクトは新しい値オブジェクトで完全に置き換え可能

## 構造

```csharp
public abstract class ValueObject
{
    // 等価性比較のための成分を取得するメソッド
    protected abstract IEnumerable<object> GetEqualityComponents();

    // 等価性の比較
    public override bool Equals(object obj) { ... }

    // ハッシュコードの生成
    public override int GetHashCode() { ... }

    // 演算子のオーバーロード
    public static bool operator ==(ValueObject left, ValueObject right) { ... }
    public static bool operator !=(ValueObject left, ValueObject right) { ... }
}
```

## 利点

- ドメインの概念をより明確に表現
- 不変性により、並行処理やキャッシュが容易
- 値の整合性と一貫性の強制
- 等価性の比較が自然
- コードの意図が明確になり、バグが減少

## 欠点

- 変更が必要な場合は新しいインスタンスを作成する必要がある
- 深い階層構造を持つ場合、コピー操作が複雑になる可能性がある
- パフォーマンスへの影響（頻繁な新しいオブジェクト作成）

## 値オブジェクトの例

- お金 (Money): 金額と通貨
- 日付範囲 (DateRange): 開始日と終了日
- 住所 (Address): 通り、市区町村、都道府県、国、郵便番号
- 緯度経度座標 (Coordinates): 緯度と経度
- 名前 (PersonName): 姓、名、ミドルネーム
- 色 (Color): RGB値またはHSL値

## ベストプラクティス

- 常に不変に保つ（すべてのフィールドを読み取り専用に）
- 値オブジェクトの等価性を正しく実装する
- バリデーションロジックをコンストラクタに含める
- ファクトリメソッドを提供して、オブジェクト生成を簡素化する
- パフォーマンスを意識した設計（頻繁に変更される場合は検討が必要）

## 実装例

サンプルコードは、`./csharp/ValueObject.cs` ファイルを参照してください。この実装例では、以下の値オブジェクトが含まれています：

- 基本的な `ValueObject` 抽象クラス
- `Money` 値オブジェクト（金額と通貨）
- `Address` 値オブジェクト（住所の各コンポーネント）
- これらの値オブジェクトを使用する例

## 関連パターン

- **エンティティパターン**: IDによる同一性を持つオブジェクト（値オブジェクトとの対比）
- **不変オブジェクトパターン**: オブジェクトの状態が作成後に変更できないパターン
- **ファクトリパターン**: 複雑な値オブジェクトの作成に使用
- **Null Objectパターン**: 特別な「空」の値オブジェクトを提供
