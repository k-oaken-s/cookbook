# ストラテジーパターン (Strategy Pattern)

## 概要

ストラテジーパターンは、アルゴリズムのファミリーをカプセル化し、それらを交換可能にするための行動デザインパターンです。このパターンにより、クライアントコードに影響を与えることなく、実行時にアルゴリズムを選択・切り替えることが可能になります。

## 目的

- アルゴリズムを定義し、カプセル化する
- アルゴリズムを実行時に選択可能にする
- クライアントから実装の詳細を隠蔽する
- 条件分岐を減らし、より柔軟で保守性の高いコードを実現する

## 構造

```
+----------------+       +-------------------------+
|                |       |                         |
|    Context     |------>|  Strategy (Interface)   |
|                |       |                         |
+----------------+       +-------------------------+
                                   ^
                                   |
                         +--------------------+
                         |                    |
               +-----------------+   +-----------------+
               |                 |   |                 |
               | ConcreteStrategyA|   | ConcreteStrategyB|
               |                 |   |                 |
               +-----------------+   +-----------------+
```

1. **Strategy（戦略）**: アルゴリズムのインターフェース
2. **ConcreteStrategy（具体的な戦略）**: アルゴリズムの特定の実装
3. **Context（コンテキスト）**: 戦略を使用するクラス

## 基本的な実装例

```csharp
// 戦略インターフェース
public interface ISortStrategy
{
    void Sort<T>(IList<T> items) where T : IComparable<T>;
}

// 具体的な戦略
public class BubbleSortStrategy : ISortStrategy
{
    public void Sort<T>(IList<T> items) where T : IComparable<T>
    {
        // バブルソートのアルゴリズム実装
    }
}

public class QuickSortStrategy : ISortStrategy
{
    public void Sort<T>(IList<T> items) where T : IComparable<T>
    {
        // クイックソートのアルゴリズム実装
    }
}

// コンテキスト
public class SortContext
{
    private ISortStrategy _strategy;

    public SortContext(ISortStrategy strategy)
    {
        _strategy = strategy;
    }

    public void SetSortStrategy(ISortStrategy strategy)
    {
        _strategy = strategy;
    }

    public void Sort<T>(IList<T> items) where T : IComparable<T>
    {
        _strategy.Sort(items);
    }
}
```

## ストラテジーパターンの利点

1. **柔軟性**: アルゴリズムを動的に切り替えられる
2. **拡張性**: 新しい戦略を追加する際に既存のコードを変更する必要がない（開放/閉鎖原則）
3. **再利用性**: 戦略を異なるコンテキストで再利用できる
4. **テスト容易性**: 各戦略を単独でテストできる
5. **関心の分離**: アルゴリズムの選択ロジックと実装が分離される
6. **条件分岐の削減**: 長い条件分岐（if-elseやswitch）をポリモーフィズムに置き換える

## ストラテジーパターンの欠点

1. **クラス数の増加**: 多数の戦略クラスが作成される
2. **コンテキストと戦略の密結合**: コンテキストが戦略を明示的に選択する必要がある
3. **クライアントの複雑化**: クライアントは適切な戦略を選択する知識が必要
4. **パフォーマンスへの影響**: 状況によっては、直接実装と比較してオーバーヘッドが生じる可能性

## 一般的な用途

ストラテジーパターンの一般的な適用例：

1. **ソートアルゴリズム**: 様々なソート方法（バブルソート、クイックソート、マージソートなど）
2. **支払い処理**: 異なる支払い方法（クレジットカード、PayPal、銀行振込など）
3. **ファイル圧縮**: 様々な圧縮アルゴリズム（ZIP、GZIP、RAR）
4. **ナビゲーション**: 異なる経路探索アルゴリズム（最短距離、最短時間、最低コスト）
5. **バリデーション**: 異なる入力検証ルール
6. **通知システム**: 様々な通知方法（メール、SMS、プッシュ通知）
7. **レンダリングエンジン**: 異なるレンダリング技術

## 実装バリエーション

1. **基本的なストラテジー**: インターフェースと具体的な実装
2. **関数型ストラテジー**: デリゲートや関数を使用（C#のFuncやActionなど）
3. **パラメータ化ストラテジー**: 戦略に状態やパラメータを持たせる
4. **コンテキスト内蔵型**: コンテキスト自体が戦略の選択ロジックを持つ

## ドメイン駆動設計での応用

DDDにおけるストラテジーパターンの応用例：

1. **ドメインポリシー**: ビジネスルールやポリシーを異なる戦略として実装
2. **価格計算**: 顧客タイプや商品カテゴリに応じた異なる価格計算戦略
3. **配送料金計算**: 地域、重量、配送速度に基づく異なる計算方法
4. **割引適用ロジック**: 様々な割引規則の実装
5. **フィルタリング戦略**: 異なる条件でエンティティをフィルタリングする戦略

## 実装例の詳細

サンプルコードは、`./csharp/Strategy.cs` ファイルを参照してください。この実装例では、以下の要素が含まれています：

1. **基本的なソート戦略**:
   - 異なるソートアルゴリズム（バブル、クイック、挿入ソート）
   - 実行時の戦略選択

2. **支払い処理戦略**:
   - クレジットカード、PayPal、銀行振込の処理
   - 各戦略に固有のパラメータ

3. **配送料金計算戦略**:
   - 国内配送、国際配送、休日配送の料金計算
   - 複合戦略パターン（装飾者パターンとの組み合わせ）

4. **フィルタリング戦略**:
   - LINQ拡張メソッドを使用した戦略パターン
   - 複合フィルター戦略

## 関連パターン

- **コマンドパターン**: 特定のアクションをカプセル化（戦略は一般にアルゴリズムをカプセル化）
- **ステートパターン**: オブジェクトの状態に基づいて振る舞いを変更
- **ブリッジパターン**: 抽象と実装を分離
- **テンプレートメソッド**: アルゴリズムの骨格を定義し、一部のステップをサブクラスで実装
- **デコレーター**: オブジェクトに新しい振る舞いを動的に追加
